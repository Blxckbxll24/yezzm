{"ast":null,"code":"/**\r\n * Special values that tell deepmerge to perform a certain action.\r\n */\nconst actions = {\n  defaultMerge: Symbol(\"deepmerge-ts: default merge\"),\n  skip: Symbol(\"deepmerge-ts: skip\")\n};\n/**\r\n * Special values that tell deepmergeInto to perform a certain action.\r\n */\nconst actionsInto = {\n  defaultMerge: actions.defaultMerge\n};\n\n/**\r\n * The default function to update meta data.\r\n */\nfunction defaultMetaDataUpdater(previousMeta, metaMeta) {\n  return metaMeta;\n}\n\n/**\r\n * Get the type of the given object.\r\n *\r\n * @param object - The object to get the type of.\r\n * @returns The type of the given object.\r\n */\nfunction getObjectType(object) {\n  if (typeof object !== \"object\" || object === null) {\n    return 0 /* ObjectType.NOT */;\n  }\n\n  if (Array.isArray(object)) {\n    return 2 /* ObjectType.ARRAY */;\n  }\n\n  if (isRecord(object)) {\n    return 1 /* ObjectType.RECORD */;\n  }\n\n  if (object instanceof Set) {\n    return 3 /* ObjectType.SET */;\n  }\n\n  if (object instanceof Map) {\n    return 4 /* ObjectType.MAP */;\n  }\n\n  return 5 /* ObjectType.OTHER */;\n}\n/**\r\n * Get the keys of the given objects including symbol keys.\r\n *\r\n * Note: Only keys to enumerable properties are returned.\r\n *\r\n * @param objects - An array of objects to get the keys of.\r\n * @returns A set containing all the keys of all the given objects.\r\n */\nfunction getKeys(objects) {\n  const keys = new Set();\n  /* eslint-disable functional/no-loop-statements -- using a loop here is more efficient. */\n  for (const object of objects) {\n    for (const key of [...Object.keys(object), ...Object.getOwnPropertySymbols(object)]) {\n      keys.add(key);\n    }\n  }\n  /* eslint-enable functional/no-loop-statements */\n  return keys;\n}\n/**\r\n * Does the given object have the given property.\r\n *\r\n * @param object - The object to test.\r\n * @param property - The property to test.\r\n * @returns Whether the object has the property.\r\n */\nfunction objectHasProperty(object, property) {\n  return typeof object === \"object\" && Object.prototype.propertyIsEnumerable.call(object, property);\n}\n/**\r\n * Get an iterable object that iterates over the given iterables.\r\n */\nfunction getIterableOfIterables(iterables) {\n  return {\n    *[Symbol.iterator]() {\n      // eslint-disable-next-line functional/no-loop-statements\n      for (const iterable of iterables) {\n        // eslint-disable-next-line functional/no-loop-statements\n        for (const value of iterable) {\n          yield value;\n        }\n      }\n    }\n  };\n}\nconst validRecordToStringValues = new Set([\"[object Object]\", \"[object Module]\"]);\n/**\r\n * Does the given object appear to be a record.\r\n */\nfunction isRecord(value) {\n  // All records are objects.\n  if (!validRecordToStringValues.has(Object.prototype.toString.call(value))) {\n    return false;\n  }\n  const {\n    constructor\n  } = value;\n  // If has modified constructor.\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (constructor === undefined) {\n    return true;\n  }\n  // eslint-disable-next-line prefer-destructuring\n  const prototype = constructor.prototype;\n  // If has modified prototype.\n  if (prototype === null || typeof prototype !== \"object\" || !validRecordToStringValues.has(Object.prototype.toString.call(prototype))) {\n    return false;\n  }\n  // If constructor does not have an Object-specific method.\n  // eslint-disable-next-line sonarjs/prefer-single-boolean-return, no-prototype-builtins\n  if (!prototype.hasOwnProperty(\"isPrototypeOf\")) {\n    return false;\n  }\n  // Most likely a record.\n  return true;\n}\n\n/**\r\n * The default strategy to merge records.\r\n *\r\n * @param values - The records.\r\n */\nfunction mergeRecords$2(values, utils, meta) {\n  const result = {};\n  /* eslint-disable functional/no-loop-statements, functional/no-conditional-statements -- using a loop here is more performant. */\n  for (const key of getKeys(values)) {\n    const propValues = [];\n    for (const value of values) {\n      if (objectHasProperty(value, key)) {\n        propValues.push(value[key]);\n      }\n    }\n    if (propValues.length === 0) {\n      continue;\n    }\n    const updatedMeta = utils.metaDataUpdater(meta, {\n      key,\n      parents: values\n    });\n    const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);\n    if (propertyResult === actions.skip) {\n      continue;\n    }\n    if (key === \"__proto__\") {\n      Object.defineProperty(result, key, {\n        value: propertyResult,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      });\n    } else {\n      result[key] = propertyResult;\n    }\n  }\n  /* eslint-enable functional/no-loop-statements, functional/no-conditional-statements */\n  return result;\n}\n/**\r\n * The default strategy to merge arrays.\r\n *\r\n * @param values - The arrays.\r\n */\nfunction mergeArrays$2(values) {\n  return values.flat();\n}\n/**\r\n * The default strategy to merge sets.\r\n *\r\n * @param values - The sets.\r\n */\nfunction mergeSets$2(values) {\n  return new Set(getIterableOfIterables(values));\n}\n/**\r\n * The default strategy to merge maps.\r\n *\r\n * @param values - The maps.\r\n */\nfunction mergeMaps$2(values) {\n  return new Map(getIterableOfIterables(values));\n}\n/**\r\n * Get the last value in the given array.\r\n */\nfunction mergeOthers$2(values) {\n  return values[values.length - 1];\n}\nvar defaultMergeFunctions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  mergeRecords: mergeRecords$2,\n  mergeArrays: mergeArrays$2,\n  mergeSets: mergeSets$2,\n  mergeMaps: mergeMaps$2,\n  mergeOthers: mergeOthers$2\n});\n\n/**\r\n * Deeply merge objects.\r\n *\r\n * @param objects - The objects to merge.\r\n */\nfunction deepmerge(...objects) {\n  return deepmergeCustom({})(...objects);\n}\nfunction deepmergeCustom(options, rootMetaData) {\n  const utils = getUtils(options, customizedDeepmerge);\n  /**\r\n   * The customized deepmerge function.\r\n   */\n  function customizedDeepmerge(...objects) {\n    return mergeUnknowns(objects, utils, rootMetaData);\n  }\n  return customizedDeepmerge;\n}\n/**\r\n * The the utils that are available to the merge functions.\r\n *\r\n * @param options - The options the user specified\r\n */\nfunction getUtils(options, customizedDeepmerge) {\n  var _a, _b;\n  return {\n    defaultMergeFunctions,\n    mergeFunctions: {\n      ...defaultMergeFunctions,\n      ...Object.fromEntries(Object.entries(options).filter(([key, option]) => Object.prototype.hasOwnProperty.call(defaultMergeFunctions, key)).map(([key, option]) => option === false ? [key, mergeOthers$2] : [key, option]))\n    },\n    metaDataUpdater: (_a = options.metaDataUpdater) !== null && _a !== void 0 ? _a : defaultMetaDataUpdater,\n    deepmerge: customizedDeepmerge,\n    useImplicitDefaultMerging: (_b = options.enableImplicitDefaultMerging) !== null && _b !== void 0 ? _b : false,\n    actions\n  };\n}\n/**\r\n * Merge unknown things.\r\n *\r\n * @param values - The values.\r\n */\nfunction mergeUnknowns(values, utils, meta) {\n  if (values.length === 0) {\n    return undefined;\n  }\n  if (values.length === 1) {\n    return mergeOthers$1(values, utils, meta);\n  }\n  const type = getObjectType(values[0]);\n  // eslint-disable-next-line functional/no-conditional-statements -- add an early escape for better performance.\n  if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n    // eslint-disable-next-line functional/no-loop-statements -- using a loop here is more performant than mapping every value and then testing every value.\n    for (let m_index = 1; m_index < values.length; m_index++) {\n      if (getObjectType(values[m_index]) === type) {\n        continue;\n      }\n      return mergeOthers$1(values, utils, meta);\n    }\n  }\n  switch (type) {\n    case 1 /* ObjectType.RECORD */:\n      {\n        return mergeRecords$1(values, utils, meta);\n      }\n    case 2 /* ObjectType.ARRAY */:\n      {\n        return mergeArrays$1(values, utils, meta);\n      }\n    case 3 /* ObjectType.SET */:\n      {\n        return mergeSets$1(values, utils, meta);\n      }\n    case 4 /* ObjectType.MAP */:\n      {\n        return mergeMaps$1(values, utils, meta);\n      }\n    default:\n      {\n        return mergeOthers$1(values, utils, meta);\n      }\n  }\n}\n/**\r\n * Merge records.\r\n *\r\n * @param values - The records.\r\n */\nfunction mergeRecords$1(values, utils, meta) {\n  const result = utils.mergeFunctions.mergeRecords(values, utils, meta);\n  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === undefined && utils.mergeFunctions.mergeRecords !== utils.defaultMergeFunctions.mergeRecords) {\n    return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);\n  }\n  return result;\n}\n/**\r\n * Merge arrays.\r\n *\r\n * @param values - The arrays.\r\n */\nfunction mergeArrays$1(values, utils, meta) {\n  const result = utils.mergeFunctions.mergeArrays(values, utils, meta);\n  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === undefined && utils.mergeFunctions.mergeArrays !== utils.defaultMergeFunctions.mergeArrays) {\n    return utils.defaultMergeFunctions.mergeArrays(values);\n  }\n  return result;\n}\n/**\r\n * Merge sets.\r\n *\r\n * @param values - The sets.\r\n */\nfunction mergeSets$1(values, utils, meta) {\n  const result = utils.mergeFunctions.mergeSets(values, utils, meta);\n  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === undefined && utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets) {\n    return utils.defaultMergeFunctions.mergeSets(values);\n  }\n  return result;\n}\n/**\r\n * Merge maps.\r\n *\r\n * @param values - The maps.\r\n */\nfunction mergeMaps$1(values, utils, meta) {\n  const result = utils.mergeFunctions.mergeMaps(values, utils, meta);\n  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === undefined && utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps) {\n    return utils.defaultMergeFunctions.mergeMaps(values);\n  }\n  return result;\n}\n/**\r\n * Merge other things.\r\n *\r\n * @param values - The other things.\r\n */\nfunction mergeOthers$1(values, utils, meta) {\n  const result = utils.mergeFunctions.mergeOthers(values, utils, meta);\n  if (result === actions.defaultMerge || utils.useImplicitDefaultMerging && result === undefined && utils.mergeFunctions.mergeOthers !== utils.defaultMergeFunctions.mergeOthers) {\n    return utils.defaultMergeFunctions.mergeOthers(values);\n  }\n  return result;\n}\n\n/**\r\n * The default strategy to merge records into a target record.\r\n *\r\n * @param m_target - The result will be mutated into this record\r\n * @param values - The records (including the target's value if there is one).\r\n */\nfunction mergeRecords(m_target, values, utils, meta) {\n  /* eslint-disable functional/no-loop-statements, functional/no-conditional-statements -- using a loop here is more performant. */\n  for (const key of getKeys(values)) {\n    const propValues = [];\n    for (const value of values) {\n      if (objectHasProperty(value, key)) {\n        propValues.push(value[key]);\n      }\n    }\n    if (propValues.length === 0) {\n      continue;\n    }\n    const updatedMeta = utils.metaDataUpdater(meta, {\n      key,\n      parents: values\n    });\n    const propertyTarget = {\n      value: propValues[0]\n    };\n    mergeUnknownsInto(propertyTarget, propValues, utils, updatedMeta);\n    if (key === \"__proto__\") {\n      Object.defineProperty(m_target, key, {\n        value: propertyTarget.value,\n        configurable: true,\n        enumerable: true,\n        writable: true\n      });\n    } else {\n      m_target.value[key] = propertyTarget.value;\n    }\n  }\n  /* eslint-enable functional/no-loop-statements, functional/no-conditional-statements */\n}\n/**\r\n * The default strategy to merge arrays into a target array.\r\n *\r\n * @param m_target - The result will be mutated into this array\r\n * @param values - The arrays (including the target's value if there is one).\r\n */\nfunction mergeArrays(m_target, values) {\n  m_target.value.push(...values.slice(1).flat());\n}\n/**\r\n * The default strategy to merge sets into a target set.\r\n *\r\n * @param m_target - The result will be mutated into this set\r\n * @param values - The sets (including the target's value if there is one).\r\n */\nfunction mergeSets(m_target, values) {\n  for (const value of getIterableOfIterables(values.slice(1))) {\n    m_target.value.add(value);\n  }\n}\n/**\r\n * The default strategy to merge maps into a target map.\r\n *\r\n * @param m_target - The result will be mutated into this map\r\n * @param values - The maps (including the target's value if there is one).\r\n */\nfunction mergeMaps(m_target, values) {\n  for (const [key, value] of getIterableOfIterables(values.slice(1))) {\n    m_target.value.set(key, value);\n  }\n}\n/**\r\n * Set the target to the last value.\r\n */\nfunction mergeOthers(m_target, values) {\n  m_target.value = values[values.length - 1];\n}\nvar defaultMergeIntoFunctions = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  mergeRecords: mergeRecords,\n  mergeArrays: mergeArrays,\n  mergeSets: mergeSets,\n  mergeMaps: mergeMaps,\n  mergeOthers: mergeOthers\n});\nfunction deepmergeInto(target, ...objects) {\n  return void deepmergeIntoCustom({})(target, ...objects);\n}\nfunction deepmergeIntoCustom(options, rootMetaData) {\n  const utils = getIntoUtils(options, customizedDeepmergeInto);\n  /**\r\n   * The customized deepmerge function.\r\n   */\n  function customizedDeepmergeInto(target, ...objects) {\n    mergeUnknownsInto({\n      value: target\n    }, [target, ...objects], utils, rootMetaData);\n  }\n  return customizedDeepmergeInto;\n}\n/**\r\n * The the utils that are available to the merge functions.\r\n *\r\n * @param options - The options the user specified\r\n */\nfunction getIntoUtils(options, customizedDeepmergeInto) {\n  var _a;\n  return {\n    defaultMergeFunctions: defaultMergeIntoFunctions,\n    mergeFunctions: {\n      ...defaultMergeIntoFunctions,\n      ...Object.fromEntries(Object.entries(options).filter(([key, option]) => Object.prototype.hasOwnProperty.call(defaultMergeIntoFunctions, key)).map(([key, option]) => option === false ? [key, mergeOthers] : [key, option]))\n    },\n    metaDataUpdater: (_a = options.metaDataUpdater) !== null && _a !== void 0 ? _a : defaultMetaDataUpdater,\n    deepmergeInto: customizedDeepmergeInto,\n    actions: actionsInto\n  };\n}\n/**\r\n * Merge unknown things into a target.\r\n *\r\n * @param m_target - The target to merge into.\r\n * @param values - The values.\r\n */\nfunction mergeUnknownsInto(m_target, values, utils, meta\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n) {\n  if (values.length === 0) {\n    return;\n  }\n  if (values.length === 1) {\n    return void mergeOthersInto(m_target, values, utils, meta);\n  }\n  const type = getObjectType(m_target.value);\n  // eslint-disable-next-line functional/no-conditional-statements -- add an early escape for better performance.\n  if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\n    // eslint-disable-next-line functional/no-loop-statements -- using a loop here is more performant than mapping every value and then testing every value.\n    for (let m_index = 1; m_index < values.length; m_index++) {\n      if (getObjectType(values[m_index]) === type) {\n        continue;\n      }\n      return void mergeOthersInto(m_target, values, utils, meta);\n    }\n  }\n  switch (type) {\n    case 1 /* ObjectType.RECORD */:\n      {\n        return void mergeRecordsInto(m_target, values, utils, meta);\n      }\n    case 2 /* ObjectType.ARRAY */:\n      {\n        return void mergeArraysInto(m_target, values, utils, meta);\n      }\n    case 3 /* ObjectType.SET */:\n      {\n        return void mergeSetsInto(m_target, values, utils, meta);\n      }\n    case 4 /* ObjectType.MAP */:\n      {\n        return void mergeMapsInto(m_target, values, utils, meta);\n      }\n    default:\n      {\n        return void mergeOthersInto(m_target, values, utils, meta);\n      }\n  }\n}\n/**\r\n * Merge records into a target record.\r\n *\r\n * @param m_target - The target to merge into.\r\n * @param values - The records.\r\n */\nfunction mergeRecordsInto(m_target, values, utils, meta) {\n  const action = utils.mergeFunctions.mergeRecords(m_target, values, utils, meta);\n  if (action === actionsInto.defaultMerge) {\n    utils.defaultMergeFunctions.mergeRecords(m_target, values, utils, meta);\n  }\n}\n/**\r\n * Merge arrays into a target array.\r\n *\r\n * @param m_target - The target to merge into.\r\n * @param values - The arrays.\r\n */\nfunction mergeArraysInto(m_target, values, utils, meta) {\n  const action = utils.mergeFunctions.mergeArrays(m_target, values, utils, meta);\n  if (action === actionsInto.defaultMerge) {\n    utils.defaultMergeFunctions.mergeArrays(m_target, values);\n  }\n}\n/**\r\n * Merge sets into a target set.\r\n *\r\n * @param m_target - The target to merge into.\r\n * @param values - The sets.\r\n */\nfunction mergeSetsInto(m_target, values, utils, meta) {\n  const action = utils.mergeFunctions.mergeSets(m_target, values, utils, meta);\n  if (action === actionsInto.defaultMerge) {\n    utils.defaultMergeFunctions.mergeSets(m_target, values);\n  }\n}\n/**\r\n * Merge maps into a target map.\r\n *\r\n * @param m_target - The target to merge into.\r\n * @param values - The maps.\r\n */\nfunction mergeMapsInto(m_target, values, utils, meta) {\n  const action = utils.mergeFunctions.mergeMaps(m_target, values, utils, meta);\n  if (action === actionsInto.defaultMerge) {\n    utils.defaultMergeFunctions.mergeMaps(m_target, values);\n  }\n}\n/**\r\n * Merge other things into a target.\r\n *\r\n * @param m_target - The target to merge into.\r\n * @param values - The other things.\r\n */\nfunction mergeOthersInto(m_target, values, utils, meta) {\n  const action = utils.mergeFunctions.mergeOthers(m_target, values, utils, meta);\n  if (action === actionsInto.defaultMerge || m_target.value === actionsInto.defaultMerge) {\n    utils.defaultMergeFunctions.mergeOthers(m_target, values);\n  }\n}\nexport { deepmerge, deepmergeCustom, deepmergeInto, deepmergeIntoCustom };","map":{"version":3,"names":["actions","defaultMerge","Symbol","skip","actionsInto","defaultMetaDataUpdater","previousMeta","metaMeta","getObjectType","object","Array","isArray","isRecord","Set","Map","getKeys","objects","keys","key","Object","getOwnPropertySymbols","add","objectHasProperty","property","prototype","propertyIsEnumerable","call","getIterableOfIterables","iterables","iterator","iterable","value","validRecordToStringValues","has","toString","constructor","undefined","hasOwnProperty","mergeRecords$2","values","utils","meta","result","propValues","push","length","updatedMeta","metaDataUpdater","parents","propertyResult","mergeUnknowns","defineProperty","configurable","enumerable","writable","mergeArrays$2","flat","mergeSets$2","mergeMaps$2","mergeOthers$2","defaultMergeFunctions","freeze","__proto__","mergeRecords","mergeArrays","mergeSets","mergeMaps","mergeOthers","deepmerge","deepmergeCustom","options","rootMetaData","getUtils","customizedDeepmerge","_a","_b","mergeFunctions","fromEntries","entries","filter","option","map","useImplicitDefaultMerging","enableImplicitDefaultMerging","mergeOthers$1","type","m_index","mergeRecords$1","mergeArrays$1","mergeSets$1","mergeMaps$1","m_target","propertyTarget","mergeUnknownsInto","slice","set","defaultMergeIntoFunctions","deepmergeInto","target","deepmergeIntoCustom","getIntoUtils","customizedDeepmergeInto","mergeOthersInto","mergeRecordsInto","mergeArraysInto","mergeSetsInto","mergeMapsInto","action"],"sources":["C:/Users/adela/Desktop/nuevoyeezy/spotifybarato/node_modules/deepmerge-ts/dist/node/index.mjs"],"sourcesContent":["/**\r\n * Special values that tell deepmerge to perform a certain action.\r\n */\r\nconst actions = {\r\n    defaultMerge: Symbol(\"deepmerge-ts: default merge\"),\r\n    skip: Symbol(\"deepmerge-ts: skip\"),\r\n};\r\n/**\r\n * Special values that tell deepmergeInto to perform a certain action.\r\n */\r\nconst actionsInto = {\r\n    defaultMerge: actions.defaultMerge,\r\n};\r\n\r\n/**\r\n * The default function to update meta data.\r\n */\r\nfunction defaultMetaDataUpdater(previousMeta, metaMeta) {\r\n    return metaMeta;\r\n}\r\n\r\n/**\r\n * Get the type of the given object.\r\n *\r\n * @param object - The object to get the type of.\r\n * @returns The type of the given object.\r\n */\r\nfunction getObjectType(object) {\r\n    if (typeof object !== \"object\" || object === null) {\r\n        return 0 /* ObjectType.NOT */;\r\n    }\r\n    if (Array.isArray(object)) {\r\n        return 2 /* ObjectType.ARRAY */;\r\n    }\r\n    if (isRecord(object)) {\r\n        return 1 /* ObjectType.RECORD */;\r\n    }\r\n    if (object instanceof Set) {\r\n        return 3 /* ObjectType.SET */;\r\n    }\r\n    if (object instanceof Map) {\r\n        return 4 /* ObjectType.MAP */;\r\n    }\r\n    return 5 /* ObjectType.OTHER */;\r\n}\r\n/**\r\n * Get the keys of the given objects including symbol keys.\r\n *\r\n * Note: Only keys to enumerable properties are returned.\r\n *\r\n * @param objects - An array of objects to get the keys of.\r\n * @returns A set containing all the keys of all the given objects.\r\n */\r\nfunction getKeys(objects) {\r\n    const keys = new Set();\r\n    /* eslint-disable functional/no-loop-statements -- using a loop here is more efficient. */\r\n    for (const object of objects) {\r\n        for (const key of [\r\n            ...Object.keys(object),\r\n            ...Object.getOwnPropertySymbols(object),\r\n        ]) {\r\n            keys.add(key);\r\n        }\r\n    }\r\n    /* eslint-enable functional/no-loop-statements */\r\n    return keys;\r\n}\r\n/**\r\n * Does the given object have the given property.\r\n *\r\n * @param object - The object to test.\r\n * @param property - The property to test.\r\n * @returns Whether the object has the property.\r\n */\r\nfunction objectHasProperty(object, property) {\r\n    return (typeof object === \"object\" &&\r\n        Object.prototype.propertyIsEnumerable.call(object, property));\r\n}\r\n/**\r\n * Get an iterable object that iterates over the given iterables.\r\n */\r\nfunction getIterableOfIterables(iterables) {\r\n    return {\r\n        *[Symbol.iterator]() {\r\n            // eslint-disable-next-line functional/no-loop-statements\r\n            for (const iterable of iterables) {\r\n                // eslint-disable-next-line functional/no-loop-statements\r\n                for (const value of iterable) {\r\n                    yield value;\r\n                }\r\n            }\r\n        },\r\n    };\r\n}\r\nconst validRecordToStringValues = new Set([\r\n    \"[object Object]\",\r\n    \"[object Module]\",\r\n]);\r\n/**\r\n * Does the given object appear to be a record.\r\n */\r\nfunction isRecord(value) {\r\n    // All records are objects.\r\n    if (!validRecordToStringValues.has(Object.prototype.toString.call(value))) {\r\n        return false;\r\n    }\r\n    const { constructor } = value;\r\n    // If has modified constructor.\r\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\r\n    if (constructor === undefined) {\r\n        return true;\r\n    }\r\n    // eslint-disable-next-line prefer-destructuring\r\n    const prototype = constructor.prototype;\r\n    // If has modified prototype.\r\n    if (prototype === null ||\r\n        typeof prototype !== \"object\" ||\r\n        !validRecordToStringValues.has(Object.prototype.toString.call(prototype))) {\r\n        return false;\r\n    }\r\n    // If constructor does not have an Object-specific method.\r\n    // eslint-disable-next-line sonarjs/prefer-single-boolean-return, no-prototype-builtins\r\n    if (!prototype.hasOwnProperty(\"isPrototypeOf\")) {\r\n        return false;\r\n    }\r\n    // Most likely a record.\r\n    return true;\r\n}\r\n\r\n/**\r\n * The default strategy to merge records.\r\n *\r\n * @param values - The records.\r\n */\r\nfunction mergeRecords$2(values, utils, meta) {\r\n    const result = {};\r\n    /* eslint-disable functional/no-loop-statements, functional/no-conditional-statements -- using a loop here is more performant. */\r\n    for (const key of getKeys(values)) {\r\n        const propValues = [];\r\n        for (const value of values) {\r\n            if (objectHasProperty(value, key)) {\r\n                propValues.push(value[key]);\r\n            }\r\n        }\r\n        if (propValues.length === 0) {\r\n            continue;\r\n        }\r\n        const updatedMeta = utils.metaDataUpdater(meta, {\r\n            key,\r\n            parents: values,\r\n        });\r\n        const propertyResult = mergeUnknowns(propValues, utils, updatedMeta);\r\n        if (propertyResult === actions.skip) {\r\n            continue;\r\n        }\r\n        if (key === \"__proto__\") {\r\n            Object.defineProperty(result, key, {\r\n                value: propertyResult,\r\n                configurable: true,\r\n                enumerable: true,\r\n                writable: true,\r\n            });\r\n        }\r\n        else {\r\n            result[key] = propertyResult;\r\n        }\r\n    }\r\n    /* eslint-enable functional/no-loop-statements, functional/no-conditional-statements */\r\n    return result;\r\n}\r\n/**\r\n * The default strategy to merge arrays.\r\n *\r\n * @param values - The arrays.\r\n */\r\nfunction mergeArrays$2(values) {\r\n    return values.flat();\r\n}\r\n/**\r\n * The default strategy to merge sets.\r\n *\r\n * @param values - The sets.\r\n */\r\nfunction mergeSets$2(values) {\r\n    return new Set(getIterableOfIterables(values));\r\n}\r\n/**\r\n * The default strategy to merge maps.\r\n *\r\n * @param values - The maps.\r\n */\r\nfunction mergeMaps$2(values) {\r\n    return new Map(getIterableOfIterables(values));\r\n}\r\n/**\r\n * Get the last value in the given array.\r\n */\r\nfunction mergeOthers$2(values) {\r\n    return values[values.length - 1];\r\n}\r\n\r\nvar defaultMergeFunctions = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    mergeRecords: mergeRecords$2,\r\n    mergeArrays: mergeArrays$2,\r\n    mergeSets: mergeSets$2,\r\n    mergeMaps: mergeMaps$2,\r\n    mergeOthers: mergeOthers$2\r\n});\r\n\r\n/**\r\n * Deeply merge objects.\r\n *\r\n * @param objects - The objects to merge.\r\n */\r\nfunction deepmerge(...objects) {\r\n    return deepmergeCustom({})(...objects);\r\n}\r\nfunction deepmergeCustom(options, rootMetaData) {\r\n    const utils = getUtils(options, customizedDeepmerge);\r\n    /**\r\n     * The customized deepmerge function.\r\n     */\r\n    function customizedDeepmerge(...objects) {\r\n        return mergeUnknowns(objects, utils, rootMetaData);\r\n    }\r\n    return customizedDeepmerge;\r\n}\r\n/**\r\n * The the utils that are available to the merge functions.\r\n *\r\n * @param options - The options the user specified\r\n */\r\nfunction getUtils(options, customizedDeepmerge) {\r\n    var _a, _b;\r\n    return {\r\n        defaultMergeFunctions,\r\n        mergeFunctions: {\r\n            ...defaultMergeFunctions,\r\n            ...Object.fromEntries(Object.entries(options)\r\n                .filter(([key, option]) => Object.prototype.hasOwnProperty.call(defaultMergeFunctions, key))\r\n                .map(([key, option]) => option === false\r\n                ? [key, mergeOthers$2]\r\n                : [key, option])),\r\n        },\r\n        metaDataUpdater: ((_a = options.metaDataUpdater) !== null && _a !== void 0 ? _a : defaultMetaDataUpdater),\r\n        deepmerge: customizedDeepmerge,\r\n        useImplicitDefaultMerging: (_b = options.enableImplicitDefaultMerging) !== null && _b !== void 0 ? _b : false,\r\n        actions,\r\n    };\r\n}\r\n/**\r\n * Merge unknown things.\r\n *\r\n * @param values - The values.\r\n */\r\nfunction mergeUnknowns(values, utils, meta) {\r\n    if (values.length === 0) {\r\n        return undefined;\r\n    }\r\n    if (values.length === 1) {\r\n        return mergeOthers$1(values, utils, meta);\r\n    }\r\n    const type = getObjectType(values[0]);\r\n    // eslint-disable-next-line functional/no-conditional-statements -- add an early escape for better performance.\r\n    if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\r\n        // eslint-disable-next-line functional/no-loop-statements -- using a loop here is more performant than mapping every value and then testing every value.\r\n        for (let m_index = 1; m_index < values.length; m_index++) {\r\n            if (getObjectType(values[m_index]) === type) {\r\n                continue;\r\n            }\r\n            return mergeOthers$1(values, utils, meta);\r\n        }\r\n    }\r\n    switch (type) {\r\n        case 1 /* ObjectType.RECORD */: {\r\n            return mergeRecords$1(values, utils, meta);\r\n        }\r\n        case 2 /* ObjectType.ARRAY */: {\r\n            return mergeArrays$1(values, utils, meta);\r\n        }\r\n        case 3 /* ObjectType.SET */: {\r\n            return mergeSets$1(values, utils, meta);\r\n        }\r\n        case 4 /* ObjectType.MAP */: {\r\n            return mergeMaps$1(values, utils, meta);\r\n        }\r\n        default: {\r\n            return mergeOthers$1(values, utils, meta);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Merge records.\r\n *\r\n * @param values - The records.\r\n */\r\nfunction mergeRecords$1(values, utils, meta) {\r\n    const result = utils.mergeFunctions.mergeRecords(values, utils, meta);\r\n    if (result === actions.defaultMerge ||\r\n        (utils.useImplicitDefaultMerging &&\r\n            result === undefined &&\r\n            utils.mergeFunctions.mergeRecords !==\r\n                utils.defaultMergeFunctions.mergeRecords)) {\r\n        return utils.defaultMergeFunctions.mergeRecords(values, utils, meta);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Merge arrays.\r\n *\r\n * @param values - The arrays.\r\n */\r\nfunction mergeArrays$1(values, utils, meta) {\r\n    const result = utils.mergeFunctions.mergeArrays(values, utils, meta);\r\n    if (result === actions.defaultMerge ||\r\n        (utils.useImplicitDefaultMerging &&\r\n            result === undefined &&\r\n            utils.mergeFunctions.mergeArrays !==\r\n                utils.defaultMergeFunctions.mergeArrays)) {\r\n        return utils.defaultMergeFunctions.mergeArrays(values);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Merge sets.\r\n *\r\n * @param values - The sets.\r\n */\r\nfunction mergeSets$1(values, utils, meta) {\r\n    const result = utils.mergeFunctions.mergeSets(values, utils, meta);\r\n    if (result === actions.defaultMerge ||\r\n        (utils.useImplicitDefaultMerging &&\r\n            result === undefined &&\r\n            utils.mergeFunctions.mergeSets !== utils.defaultMergeFunctions.mergeSets)) {\r\n        return utils.defaultMergeFunctions.mergeSets(values);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Merge maps.\r\n *\r\n * @param values - The maps.\r\n */\r\nfunction mergeMaps$1(values, utils, meta) {\r\n    const result = utils.mergeFunctions.mergeMaps(values, utils, meta);\r\n    if (result === actions.defaultMerge ||\r\n        (utils.useImplicitDefaultMerging &&\r\n            result === undefined &&\r\n            utils.mergeFunctions.mergeMaps !== utils.defaultMergeFunctions.mergeMaps)) {\r\n        return utils.defaultMergeFunctions.mergeMaps(values);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Merge other things.\r\n *\r\n * @param values - The other things.\r\n */\r\nfunction mergeOthers$1(values, utils, meta) {\r\n    const result = utils.mergeFunctions.mergeOthers(values, utils, meta);\r\n    if (result === actions.defaultMerge ||\r\n        (utils.useImplicitDefaultMerging &&\r\n            result === undefined &&\r\n            utils.mergeFunctions.mergeOthers !==\r\n                utils.defaultMergeFunctions.mergeOthers)) {\r\n        return utils.defaultMergeFunctions.mergeOthers(values);\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * The default strategy to merge records into a target record.\r\n *\r\n * @param m_target - The result will be mutated into this record\r\n * @param values - The records (including the target's value if there is one).\r\n */\r\nfunction mergeRecords(m_target, values, utils, meta) {\r\n    /* eslint-disable functional/no-loop-statements, functional/no-conditional-statements -- using a loop here is more performant. */\r\n    for (const key of getKeys(values)) {\r\n        const propValues = [];\r\n        for (const value of values) {\r\n            if (objectHasProperty(value, key)) {\r\n                propValues.push(value[key]);\r\n            }\r\n        }\r\n        if (propValues.length === 0) {\r\n            continue;\r\n        }\r\n        const updatedMeta = utils.metaDataUpdater(meta, {\r\n            key,\r\n            parents: values,\r\n        });\r\n        const propertyTarget = { value: propValues[0] };\r\n        mergeUnknownsInto(propertyTarget, propValues, utils, updatedMeta);\r\n        if (key === \"__proto__\") {\r\n            Object.defineProperty(m_target, key, {\r\n                value: propertyTarget.value,\r\n                configurable: true,\r\n                enumerable: true,\r\n                writable: true,\r\n            });\r\n        }\r\n        else {\r\n            m_target.value[key] = propertyTarget.value;\r\n        }\r\n    }\r\n    /* eslint-enable functional/no-loop-statements, functional/no-conditional-statements */\r\n}\r\n/**\r\n * The default strategy to merge arrays into a target array.\r\n *\r\n * @param m_target - The result will be mutated into this array\r\n * @param values - The arrays (including the target's value if there is one).\r\n */\r\nfunction mergeArrays(m_target, values) {\r\n    m_target.value.push(...values.slice(1).flat());\r\n}\r\n/**\r\n * The default strategy to merge sets into a target set.\r\n *\r\n * @param m_target - The result will be mutated into this set\r\n * @param values - The sets (including the target's value if there is one).\r\n */\r\nfunction mergeSets(m_target, values) {\r\n    for (const value of getIterableOfIterables(values.slice(1))) {\r\n        m_target.value.add(value);\r\n    }\r\n}\r\n/**\r\n * The default strategy to merge maps into a target map.\r\n *\r\n * @param m_target - The result will be mutated into this map\r\n * @param values - The maps (including the target's value if there is one).\r\n */\r\nfunction mergeMaps(m_target, values) {\r\n    for (const [key, value] of getIterableOfIterables(values.slice(1))) {\r\n        m_target.value.set(key, value);\r\n    }\r\n}\r\n/**\r\n * Set the target to the last value.\r\n */\r\nfunction mergeOthers(m_target, values) {\r\n    m_target.value = values[values.length - 1];\r\n}\r\n\r\nvar defaultMergeIntoFunctions = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    mergeRecords: mergeRecords,\r\n    mergeArrays: mergeArrays,\r\n    mergeSets: mergeSets,\r\n    mergeMaps: mergeMaps,\r\n    mergeOthers: mergeOthers\r\n});\r\n\r\nfunction deepmergeInto(target, ...objects) {\r\n    return void deepmergeIntoCustom({})(target, ...objects);\r\n}\r\nfunction deepmergeIntoCustom(options, rootMetaData) {\r\n    const utils = getIntoUtils(options, customizedDeepmergeInto);\r\n    /**\r\n     * The customized deepmerge function.\r\n     */\r\n    function customizedDeepmergeInto(target, ...objects) {\r\n        mergeUnknownsInto({ value: target }, [target, ...objects], utils, rootMetaData);\r\n    }\r\n    return customizedDeepmergeInto;\r\n}\r\n/**\r\n * The the utils that are available to the merge functions.\r\n *\r\n * @param options - The options the user specified\r\n */\r\nfunction getIntoUtils(options, customizedDeepmergeInto) {\r\n    var _a;\r\n    return {\r\n        defaultMergeFunctions: defaultMergeIntoFunctions,\r\n        mergeFunctions: {\r\n            ...defaultMergeIntoFunctions,\r\n            ...Object.fromEntries(Object.entries(options)\r\n                .filter(([key, option]) => Object.prototype.hasOwnProperty.call(defaultMergeIntoFunctions, key))\r\n                .map(([key, option]) => option === false\r\n                ? [key, mergeOthers]\r\n                : [key, option])),\r\n        },\r\n        metaDataUpdater: ((_a = options.metaDataUpdater) !== null && _a !== void 0 ? _a : defaultMetaDataUpdater),\r\n        deepmergeInto: customizedDeepmergeInto,\r\n        actions: actionsInto,\r\n    };\r\n}\r\n/**\r\n * Merge unknown things into a target.\r\n *\r\n * @param m_target - The target to merge into.\r\n * @param values - The values.\r\n */\r\nfunction mergeUnknownsInto(m_target, values, utils, meta\r\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\r\n) {\r\n    if (values.length === 0) {\r\n        return;\r\n    }\r\n    if (values.length === 1) {\r\n        return void mergeOthersInto(m_target, values, utils, meta);\r\n    }\r\n    const type = getObjectType(m_target.value);\r\n    // eslint-disable-next-line functional/no-conditional-statements -- add an early escape for better performance.\r\n    if (type !== 0 /* ObjectType.NOT */ && type !== 5 /* ObjectType.OTHER */) {\r\n        // eslint-disable-next-line functional/no-loop-statements -- using a loop here is more performant than mapping every value and then testing every value.\r\n        for (let m_index = 1; m_index < values.length; m_index++) {\r\n            if (getObjectType(values[m_index]) === type) {\r\n                continue;\r\n            }\r\n            return void mergeOthersInto(m_target, values, utils, meta);\r\n        }\r\n    }\r\n    switch (type) {\r\n        case 1 /* ObjectType.RECORD */: {\r\n            return void mergeRecordsInto(m_target, values, utils, meta);\r\n        }\r\n        case 2 /* ObjectType.ARRAY */: {\r\n            return void mergeArraysInto(m_target, values, utils, meta);\r\n        }\r\n        case 3 /* ObjectType.SET */: {\r\n            return void mergeSetsInto(m_target, values, utils, meta);\r\n        }\r\n        case 4 /* ObjectType.MAP */: {\r\n            return void mergeMapsInto(m_target, values, utils, meta);\r\n        }\r\n        default: {\r\n            return void mergeOthersInto(m_target, values, utils, meta);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Merge records into a target record.\r\n *\r\n * @param m_target - The target to merge into.\r\n * @param values - The records.\r\n */\r\nfunction mergeRecordsInto(m_target, values, utils, meta) {\r\n    const action = utils.mergeFunctions.mergeRecords(m_target, values, utils, meta);\r\n    if (action === actionsInto.defaultMerge) {\r\n        utils.defaultMergeFunctions.mergeRecords(m_target, values, utils, meta);\r\n    }\r\n}\r\n/**\r\n * Merge arrays into a target array.\r\n *\r\n * @param m_target - The target to merge into.\r\n * @param values - The arrays.\r\n */\r\nfunction mergeArraysInto(m_target, values, utils, meta) {\r\n    const action = utils.mergeFunctions.mergeArrays(m_target, values, utils, meta);\r\n    if (action === actionsInto.defaultMerge) {\r\n        utils.defaultMergeFunctions.mergeArrays(m_target, values);\r\n    }\r\n}\r\n/**\r\n * Merge sets into a target set.\r\n *\r\n * @param m_target - The target to merge into.\r\n * @param values - The sets.\r\n */\r\nfunction mergeSetsInto(m_target, values, utils, meta) {\r\n    const action = utils.mergeFunctions.mergeSets(m_target, values, utils, meta);\r\n    if (action === actionsInto.defaultMerge) {\r\n        utils.defaultMergeFunctions.mergeSets(m_target, values);\r\n    }\r\n}\r\n/**\r\n * Merge maps into a target map.\r\n *\r\n * @param m_target - The target to merge into.\r\n * @param values - The maps.\r\n */\r\nfunction mergeMapsInto(m_target, values, utils, meta) {\r\n    const action = utils.mergeFunctions.mergeMaps(m_target, values, utils, meta);\r\n    if (action === actionsInto.defaultMerge) {\r\n        utils.defaultMergeFunctions.mergeMaps(m_target, values);\r\n    }\r\n}\r\n/**\r\n * Merge other things into a target.\r\n *\r\n * @param m_target - The target to merge into.\r\n * @param values - The other things.\r\n */\r\nfunction mergeOthersInto(m_target, values, utils, meta) {\r\n    const action = utils.mergeFunctions.mergeOthers(m_target, values, utils, meta);\r\n    if (action === actionsInto.defaultMerge ||\r\n        m_target.value === actionsInto.defaultMerge) {\r\n        utils.defaultMergeFunctions.mergeOthers(m_target, values);\r\n    }\r\n}\r\n\r\nexport { deepmerge, deepmergeCustom, deepmergeInto, deepmergeIntoCustom };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}